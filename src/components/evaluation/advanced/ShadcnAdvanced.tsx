import { ContentContainer, SectionBlock, SubsectionBlock, CalloutNote } from '@/components/content';

export function ShadcnAdvanced() {
    return (
        <ContentContainer>
            <SectionBlock title="Advanced">
                <SubsectionBlock heading="Design Tokens, Theming & Styling Ownership">
                    <p>
                        <strong>Tailwind as the styling mechanism:</strong> shadcn/ui components are styled exclusively with Tailwind
                        utility classes. Your design tokens live in <code>tailwind.config.js</code>—colors, spacing, typography, shadows,
                        border radius. This is not abstracted away. You define the token system, and components reference it via Tailwind
                        classes.
                    </p>
                    <p>
                        <strong>Token ownership:</strong> Unlike provider-based theming systems, there's no runtime theme object. Tokens
                        are build-time CSS variables generated by Tailwind. Changes to tokens require rebuilding styles. This makes theming
                        predictable and explicit but also inflexible for runtime theme switching without additional tooling.
                    </p>
                    <p>
                        <strong>Co-location benefits:</strong> Styles live directly on components via className props. This makes it easy
                        to see what styles apply where, without hunting through theme objects or CSS files. Modifications are local and
                        immediate. The tradeoff is verbosity—Tailwind classes can be long and repetitive.
                    </p>
                    <p>
                        <strong>Utility-first scaling tradeoffs:</strong> At scale, Tailwind encourages extracting repeated patterns into
                        reusable components or CSS layers. Teams that resist this end up with brittle, copy-pasted class strings. Teams that
                        embrace it maintain a component library that reflects their design system. This is intentional work, not automatic.
                    </p>
                    <p>
                        <strong>Theme consistency enforcement:</strong> Tailwind and shadcn/ui provide no guardrails. Developers can use
                        arbitrary values (<code>bg-[#ff0000]</code>) that bypass your token system. Consistency is enforced through code
                        review, linting (ESLint plugins), and team discipline. If your team lacks these, your UI will drift.
                    </p>
                </SubsectionBlock>

                <SubsectionBlock heading="Composition & API Surface Control">
                    <p>
                        <strong>Radix as the foundation:</strong> shadcn/ui components are built on Radix primitives (Dialog, Select,
                        Accordion, etc.). Radix handles accessibility, keyboard navigation, and focus management. shadcn/ui adds Tailwind
                        styling and sensible composition patterns. You own both layers.
                    </p>
                    <p>
                        <strong>Composition-first design:</strong> Components are designed to be composed, not configured. A Dialog is
                        composed from DialogTrigger, DialogContent, DialogHeader, DialogTitle, DialogFooter. You arrange these however
                        your design requires. This is powerful but verbose. Every use site requires explicit composition.
                    </p>
                    <p>
                        <strong>Freedom to change markup and behavior:</strong> Because components live in your codebase, you can modify
                        them freely. Need a Dialog with a different header structure? Edit <code>components/ui/dialog.tsx</code>. Want a
                        Button that tracks analytics on click? Add it. This freedom is the entire point of the model.
                    </p>
                    <p>
                        <strong>API consistency responsibility:</strong> With freedom comes responsibility. If different developers modify
                        Button differently across the codebase, your API surface fragments. Maintaining consistency requires governance—code
                        review, component documentation, and clear ownership. This is not provided by shadcn/ui. It's your job.
                    </p>
                    <p>
                        <strong>Long-term benefits of explicit APIs:</strong> When everything is explicit, debugging is straightforward.
                        There's no magic, no hidden behavior. When a component breaks, the code is in front of you. When you need to change
                        behavior, you edit the file. This clarity is valuable over years of maintenance.
                    </p>
                </SubsectionBlock>

                <SubsectionBlock heading="Accessibility Responsibilities">
                    <p>
                        <strong>What Radix handles automatically:</strong> Radix primitives provide ARIA roles, states, and properties out
                        of the box. Dialogs have <code>role="dialog"</code>, <code>aria-modal="true"</code>, and proper focus trapping.
                        Select components handle <code>aria-expanded</code>, <code>aria-selected</code>, and keyboard navigation. This is
                        reliable and well-tested.
                    </p>
                    <p>
                        <strong>What teams must still manage:</strong> Radix handles interactive primitives, but you're responsible for
                        semantic HTML, heading hierarchy, alt text, and label associations. If you wrap a Radix Select in custom markup
                        that breaks focus order, that's on you. If you forget to add labels to form inputs, that's on you.
                    </p>
                    <p>
                        <strong>ARIA responsibilities:</strong> When you modify components, you must preserve ARIA attributes. If you add
                        custom behavior (e.g., a Button that opens a popover), you need to wire <code>aria-haspopup</code> and
                        <code>aria-controls</code> yourself. Radix doesn't know about your custom patterns.
                    </p>
                    <p>
                        <strong>Keyboard navigation expectations:</strong> Radix handles primitives, but complex interactions (e.g., a
                        command palette with nested navigation) require additional keyboard logic. You're responsible for ensuring Tab,
                        Arrow keys, Enter, and Escape work as expected across your custom components.
                    </p>
                    <p>
                        <strong>Testing and regression risks:</strong> Because accessibility is split between Radix (handled) and your code
                        (manual), regressions are possible. A developer editing a component might inadvertently break focus management or
                        remove ARIA attributes. Accessibility testing (automated and manual) is your responsibility.
                    </p>
                </SubsectionBlock>

                <SubsectionBlock heading="Performance Characteristics">
                    <p>
                        <strong>Minimal abstraction overhead:</strong> shadcn/ui components have almost no runtime abstraction. There's no
                        theming context, no provider tree, no hook dependencies beyond Radix. Components are lightweight React components
                        that render markup and classes. This keeps the runtime footprint small.
                    </p>
                    <p>
                        <strong>Smaller runtime footprint:</strong> Because you only copy the components you use, and those components have
                        minimal dependencies, bundle size is predictable. A Button is just a Button—no theme provider, no global state, no
                        hook utilities. Tree-shaking is effective because components are isolated files.
                    </p>
                    <p>
                        <strong>Cost shifting from runtime to development time:</strong> The performance cost of shadcn/ui is not at runtime—it's
                        at development time. You spend more time composing components, maintaining consistency, and ensuring accessibility.
                        The app runs faster, but building it takes longer.
                    </p>
                    <p>
                        <strong>Performance gains through ownership:</strong> Because you own the code, you can optimize aggressively. Want
                        to lazy-load a Dialog? Wrap it in React.lazy. Want to memoize a complex Select? Add React.memo directly to the component.
                        There's no abstraction to work around—just code you control.
                    </p>
                    <p>
                        <strong>Where teams can accidentally regress performance:</strong> Freedom enables mistakes. Developers can add heavy
                        dependencies to components (e.g., importing a large icon library directly instead of tree-shaking). They can add
                        unnecessary state, cause re-renders, or bloat components with logic. Performance is not protected by the library—it's
                        protected by code review and team discipline.
                    </p>

                    <h3>Maintenance & Evolution Cost</h3>
                    <p>
                        <strong>"You own it forever" implications:</strong> When you copy a component into your codebase, you own it permanently.
                        If shadcn/ui releases an improved version, you don't get it automatically. You manually review the changes, decide if
                        they're relevant, and merge them yourself. This is intentional. It avoids breaking changes but requires active maintenance.
                    </p>
                    <p>
                        <strong>Upgrade paths for Radix:</strong> Radix primitives are dependencies you manage via npm. When Radix releases a
                        new version, you upgrade it like any other dependency. If the API changes, you must update your components accordingly.
                        This is rare (Radix is stable), but it's your responsibility.
                    </p>
                    <p>
                        <strong>Internal API drift risks:</strong> As different developers modify components over time, APIs can drift. One team
                        adds a <code>size</code> prop to Button. Another team adds <code>loading</code>. A third team adds <code>icon</code>.
                        Without coordination, you end up with inconsistent APIs across components. This is managed through documentation, component
                        audits, and governance—not tooling.
                    </p>
                    <p>
                        <strong>Documentation burden:</strong> Because components live in your codebase and evolve independently, you need internal
                        documentation. What props does Button accept? What variants are supported? How do you compose a Dialog? Teams that skip
                        documentation end up with tribal knowledge and slow onboarding. This is real cost.
                    </p>
                    <p>
                        <strong>Onboarding cost for new team members:</strong> New developers joining your team need to learn your component system,
                        not shadcn/ui's. They need to understand your Tailwind config, your composition patterns, your accessibility standards, and
                        your internal documentation. This onboarding is slower than "install library, read docs." It's also more valuable long-term,
                        because they're learning your system.
                    </p>
                </SubsectionBlock>
            </SectionBlock>
        </ContentContainer>
    );
}
